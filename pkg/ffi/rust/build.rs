// Build script for generating C header bindings
//
// This generates the C header file (bindings.h) that CGO will use
// to interface with the Rust library.

use std::env;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

fn main() {
    // Get output directory for generated files
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Generate C header with function declarations
    let header = generate_c_header();

    // Write header to bindings.h
    let header_path = out_dir.join("bindings.h");
    let mut file = File::create(&header_path).expect("Failed to create bindings.h");
    file.write_all(header.as_bytes())
        .expect("Failed to write bindings.h");

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/lib.rs");

    // Also copy to parent directory for easier CGO access
    let parent_header = PathBuf::from("../bindings.h");
    std::fs::copy(&header_path, &parent_header).ok();
}

fn generate_c_header() -> String {
    r#"
/*
 * C bindings for zcash-t2o-ffi
 *
 * This header is auto-generated by build.rs
 * Do not modify manually
 */

#ifndef ZCASH_T2O_FFI_H
#define ZCASH_T2O_FFI_H

#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================
 * Opaque types
 * ======================================================================== */

/* Opaque handle to a PCZT structure */
typedef struct PCZT PCZT;

/* ========================================================================
 * Error handling
 * ======================================================================== */

/* Error codes returned by FFI functions */
typedef enum {
    FFI_OK = 0,
    FFI_ERROR_NULL_POINTER = 1,
    FFI_ERROR_INVALID_PCZT = 2,
    FFI_ERROR_PROVING_FAILED = 3,
    FFI_ERROR_SERIALIZATION_FAILED = 4,
    FFI_ERROR_ORCHARD_CRYPTO_FAILED = 5,
} FFIErrorCode;

/* Result type for operations that return data */
typedef struct {
    FFIErrorCode error_code;
    uint8_t *data;    /* Output data (caller must free with ffi_free_bytes) */
    size_t data_len;  /* Length of output data */
} FFIResult;

/* ========================================================================
 * Memory management
 * ======================================================================== */

/*
 * Free a byte array allocated by Rust
 *
 * Must be called on any data returned by FFI functions
 */
void ffi_free_bytes(uint8_t *ptr, size_t len);

/*
 * Get the last error message
 *
 * Returns a null-terminated string (caller must free with ffi_free_string)
 */
char *ffi_last_error_message(void);

/*
 * Free an error message string
 */
void ffi_free_string(char *s);

/* ========================================================================
 * Prover operations
 * ======================================================================== */

/*
 * Generate Orchard ZK proofs for a PCZT
 *
 * This function:
 *   1. Deserializes the PCZT from bytes
 *   2. Generates zero-knowledge proofs for all Orchard actions
 *   3. Serializes the PCZT back to bytes with proofs included
 *
 * Parameters:
 *   - pczt_bytes: Input PCZT bytes
 *   - pczt_len: Length of input PCZT
 *
 * Returns:
 *   - FFIResult with proved PCZT bytes (or error)
 */
FFIResult ffi_prove_pczt(const uint8_t *pczt_bytes, size_t pczt_len);

/* ========================================================================
 * Orchard cryptographic operations
 * ======================================================================== */

/*
 * Derive Orchard note commitment
 *
 * Parameters:
 *   - recipient: 43-byte Orchard address (diversifier + pk_d)
 *   - value: Note value in zatoshis
 *   - rseed: 32-byte random seed
 *   - rho: 32-byte nullifier base
 *   - cmx_out: [OUTPUT] 32-byte note commitment
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_note_commitment(
    const uint8_t recipient[43],
    uint64_t value,
    const uint8_t rseed[32],
    const uint8_t rho[32],
    uint8_t cmx_out[32]
);

/*
 * Derive Orchard ephemeral key
 *
 * Parameters:
 *   - esk: 32-byte ephemeral secret key
 *   - epk_out: [OUTPUT] 32-byte ephemeral public key
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_ephemeral_key(
    const uint8_t esk[32],
    uint8_t epk_out[32]
);

/*
 * Encrypt Orchard note
 *
 * Parameters:
 *   - recipient: 43-byte Orchard address
 *   - value: Note value
 *   - rseed: 32-byte random seed
 *   - memo: 512-byte memo field
 *   - esk: 32-byte ephemeral secret key
 *   - epk: 32-byte ephemeral public key
 *   - enc_ciphertext_out: [OUTPUT] 580-byte encrypted ciphertext
 *   - out_ciphertext_out: [OUTPUT] 80-byte outgoing ciphertext
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_encrypt_note(
    const uint8_t recipient[43],
    uint64_t value,
    const uint8_t rseed[32],
    const uint8_t memo[512],
    const uint8_t esk[32],
    const uint8_t epk[32],
    uint8_t enc_ciphertext_out[580],
    uint8_t out_ciphertext_out[80]
);

/*
 * Compute Orchard value commitment
 *
 * Parameters:
 *   - value: Note value
 *   - rcv: 32-byte randomness
 *   - cv_out: [OUTPUT] 32-byte value commitment
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_value_commitment(
    uint64_t value,
    const uint8_t rcv[32],
    uint8_t cv_out[32]
);

/*
 * Derive Orchard nullifier
 *
 * Parameters:
 *   - rho: 32-byte nullifier base
 *   - sk: 32-byte spending key
 *   - nf_out: [OUTPUT] 32-byte nullifier
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_derive_nullifier(
    const uint8_t rho[32],
    const uint8_t sk[32],
    uint8_t nf_out[32]
);

/*
 * Derive Orchard randomized verification key
 *
 * Parameters:
 *   - sk: 32-byte spending key
 *   - alpha: 32-byte randomizer
 *   - rk_out: [OUTPUT] 32-byte randomized key
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_orchard_randomized_key(
    const uint8_t sk[32],
    const uint8_t alpha[32],
    uint8_t rk_out[32]
);

/*
 * Add Pallas scalars (for bsk computation)
 *
 * Parameters:
 *   - a: 32-byte scalar
 *   - b: 32-byte scalar
 *   - result_out: [OUTPUT] 32-byte scalar (a + b mod r)
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_pallas_scalar_add(
    const uint8_t a[32],
    const uint8_t b[32],
    uint8_t result_out[32]
);

/*
 * Create RedPallas spend authorization signature
 *
 * Parameters:
 *   - sk: 32-byte dummy spending key
 *   - alpha: 32-byte randomizer
 *   - sighash: 32-byte transaction hash
 *   - sig_out: [OUTPUT] 64-byte RedPallas signature
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_reddsa_sign_spend_auth(
    const uint8_t sk[32],
    const uint8_t alpha[32],
    const uint8_t sighash[32],
    uint8_t sig_out[64]
);

/*
 * Create RedPallas binding signature
 *
 * Parameters:
 *   - bsk: 32-byte binding signature key
 *   - sighash: 32-byte transaction hash
 *   - sig_out: [OUTPUT] 64-byte RedPallas signature
 *
 * Returns: FFI_OK or error code
 */
FFIErrorCode ffi_reddsa_sign_binding(
    const uint8_t bsk[32],
    const uint8_t sighash[32],
    uint8_t sig_out[64]
);

#ifdef __cplusplus
}
#endif

#endif /* ZCASH_T2O_FFI_H */
"#
    .to_string()
}
